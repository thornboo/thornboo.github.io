[{"title":"Git Commit message 规范指南","url":"/2022/04/18/Git-Commit-message-%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97/","content":"前言：git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交。但是一般来说，commit message 应该清晰明了，说明本次提交的目的。\n一、git提交格式代码格式为： git commit -m &quot;hello world&quot;\n上面代码的 -m 参数，就是用来指定 commit mesage 的。  如果一行不够，可以只执行 git commit ，就会跳出文本编辑器，让你写多行。\n二、commit message格式代码格式： &lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;\n\ntype（必须）用于说明 git commit 的类别，只允许使用下面的标识 。如果 type 为 feat 和 fix ，则该commit将肯定出现在 Change log 之中。其他情况由你决定，要不要放入 Change log ，（建议不要放入）。\nfeat:增加新功能。fix: 修复问题&#x2F;bug 。docs: 文档&#x2F;注释。style: 代码风格相关&#x2F;格式（不影响代码运行的变动）。pre: 优化&#x2F;性能提升。refactor: 代码重构。test: 测试相关 。chore: 依赖更新&#x2F;脚手架配置修改（构建过程或辅助工具的变动）。revert: 撤销修改（回滚到上一个版本） 。merge: 代码合并 。types: 类型定义文件更改。wip: 开发中。workflow: 工作流改进 。\n\nscope（可选）scope用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。如果你的修改影响了不止一个scope，你可以使用* 代替。\n\nsubject（必须）subject是 commit目的的简短描述，不超过50个字符。建议使用中文（毕竟中国人用中文描述问题能更清楚一些），单词开头的第一个字母小写，且结尾不加句号或其他标点符号。\n\n\n三、生成change log如果你的所有 Commit 都符合格式，那么发布新版本时， Change log 就可以用脚本自动生成。生成的文档应该包括以下三个部分：\n\nNew features\nBug fixes\nBreaking changes\n\n每个部分都会罗列相关的 commit ，并且有指向这些 commit 的链接。并且生成的文档允许手动修改，所以发布前，你还可以添加其他内容。\nconventional-changelog就是生成 Change log 的工具，运行下面的命令即可。\nnpm install -g conventional-changelogcd my-projectconventional-changelog -p angular -i CHANGELOG.md -w","tags":["git教程"]},{"title":"Java Web项目搭建并部署Tomcat","url":"/2022/04/18/Java-Web%E9%A1%B9%E7%9B%AE%E6%90%AD%E5%BB%BA%E5%B9%B6%E9%83%A8%E7%BD%B2Tomcat/","content":"对于刚接触java web的时候，部署tomcat也是一个很常见的问题。\n一、首先创建一个java项目，填好项目名称路径，其他什么都不用改直接下一步。\n\n\n二、创建完成后，在项目上右键，选择Add Framework support –&gt; java EE 下选择web application，右侧对话框选择版本和创建web.xml文件。\n\n三、完成之后，项目结构也会随之变化。\n四、我们需要在WEB-INF下创建classes，lib两个文件夹。\n五、编辑项目结构，按步骤选择填写编译文件输出位置，即WEB-INF下的classes文件夹。\n六、添加项目依赖的jar包，jar包放在WEB-INF&#x2F;lib下。\n\n\n\n七、接下来配置tomcat。\n八、添加本地tomcat，并配置其他选项。\n九、配置tomcat基本信息（版本，本地tomcat安装位置，jre等）。\n十、部署项目。\n\n十一、部署后项目发布地址已经自行匹配完成，返回修改tomcat信息剩余信息。\n十二、最后点击OK就基本上完成创建了。"},{"title":"Windows下配置Git并连接上GitHub和设置代理","url":"/2022/04/18/Windows%E4%B8%8B%E9%85%8D%E7%BD%AEGit%E5%B9%B6%E8%BF%9E%E6%8E%A5%E4%B8%8AGitHub%E5%92%8C%E8%AE%BE%E7%BD%AE%E4%BB%A3%E7%90%86/","content":"本文将详细介绍 Windows 下配置 Git 连接上 GitHub和设置代理。\n一、配置GitHub\n首先进入 GitHub 的 settings 页面，https://github.com/settings/keys\n如果之前设置过key，需要删除过期的key，如果没有就跳过。\n点击 New SSH key，你需要输入 Title（选填） 和 Key，由于现在还没有 key，所以接下来去获取key。\n打开 Git Bash并运行 rm -rf ~/.ssh/* （建议复制运行） 把本地现有的 ssh key 都删掉。\n运行 ssh-keygen -t rsa -C &quot;填写你的github邮箱&quot;，注意填写的是你的github邮箱！\n接着回车三次，什么都不要输入即可。\n运行 cat ~/.ssh/id_rsa.pub，得到一串密钥，完整的复制这串密钥，回到上面第 3 步的页面，在 Key 里粘贴刚刚你你复制的那串密钥。\n接着点击 Add SSH key， 回到 Git Bash 运行 ssh -T git@github.com，输入yes。\n如果你看到 Permission denied (publickey). 就说明你失败了，请回到第 1 步重来；如果你看到 Hi FrankFang! You’ve successfully authenticated, but GitHub does not provide shell access. 就说明你成功了！\n\n二、配置本地Git只有五局命令，依次在CLI中运行:\n\ngit config --global user.name 你的用户名\ngit config --global user.email 你的邮箱\ngit config --global push.default matching    其意是如果你执行 git push 但没有指定分支，它将 push 所有你本地的分支到远程仓库中对应匹配的分支。\ngit config --global core.quotepath false     设为false的话，就不会对0×80以上的字符进行quote。中文显示正常。\ngit config --global core.editor &quot;vim&quot;   设置编辑器为vim。\n\n三、设置代理如果使用的是 socks5，本地 ip 和端口是 127.0.0.1:1080，则：\n\n只设置GitHub的代理，忽略Gitee：\n\ngit config --global http.https://github.com.proxy socks5://127.0.0.1:1080git config --global https.https://github.com.proxy socks5://127.0.0.1:1080# 取消设置的代理git config --global --unset http.https://github.com.proxygit config --global --unset https.https://github.com.proxy\n\n\nGit设置全面代理：\n\ngit config --global http.proxy socks5://127.0.0.1:1080git config --global https.proxy socks5://127.0.0.1:1080# 取消设置的代理git config --global --unset http.proxygit config --global --unset https.proxy\n\n四、Git其他操作\ngit 的配置文件在 ~/.gitconfig ，仓库的配置文件是仓库内的 .git/config。\n加上 --global 参数，则设置内容对当前用户生效，不加 --global 则对当前仓库生效。\n检查配置情况：git config --list 。\n显示历史记录时每个提交的信息显示一行： git --global config format.pretty oneline。\n\n","tags":["git教程"]},{"title":"github重新修改历史commit的name和email信息","url":"/2022/04/17/github%E9%87%8D%E6%96%B0%E4%BF%AE%E6%94%B9%E5%8E%86%E5%8F%B2commit%E7%9A%84name%E5%92%8Cemail%E4%BF%A1%E6%81%AF/","content":"前言：本文将介绍如何批量修改 git 历史提交记录中的 username 和 email。\n1、给你的repo创建一个全新的clone，并复制粘贴脚本。git clone --bare https://github.com/user/repo.gitcd repo.git\n\n2、根据你的信息修改以下变量：旧的Email地址，正确的用户名，正确的邮件地址；然后按Enter键执行脚本。#!/bin/shgit filter-branch --env-filter &#x27;OLD_EMAIL=&quot;旧的Email地址&quot;CORRECT_NAME=&quot;正确的用户名&quot;CORRECT_EMAIL=&quot;正确的邮件地址&quot;if [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]then    export GIT_COMMITTER_NAME=&quot;$CORRECT_NAME&quot;    export GIT_COMMITTER_EMAIL=&quot;$CORRECT_EMAIL&quot;fiif [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]then    export GIT_AUTHOR_NAME=&quot;$CORRECT_NAME&quot;    export GIT_AUTHOR_EMAIL=&quot;$CORRECT_EMAIL&quot;fi&#x27; --tag-name-filter cat -- --branches --tags\n\n3、用git log命令看看新 Git 历史有没有错误，如果没有错误就把把正确历史 push 到 Github。git push --force --tags origin &#x27;refs/heads/*&#x27;\n\n4、接着删掉刚刚临时创建的 clone。cd ..rm -rf repo.git\n\n备注：如何正确设置你的 git 个人信息（全局设置）git config --global user.email &quot;你的邮件地址&quot;git config --global user.name &quot;你的Github用户名&quot;","tags":["git教程"]},{"title":"npm WARN config global ,解决方法","url":"/2022/09/23/npm-WARN-config-global-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","content":"出现问题原因在安装配置node时，检查node没问题，但是检查npm就出现npm warn config global --global, --local are deprecated. use --location=global instead.的报警；问题出在以前版本npm的命令一般时XXX -g 但是随着版本更替，这个老方法已被弃用，\n解决方法\n修改npm的配置项（不推荐）\n\n需要修改两个文件npm和npm.cmd，\n将npm文件的第23行，修改为prefix --location=global\n将npm.cmd文件的第12行，修改为prefix --location=global\n\n\n配置全局 ‘–global’\n\n使用命令更新npm版本 npm install -g npm\n但是过程中可能会发生Unexpected token &#39;.&#39; 这个错误，而这个错误其实并不是 Node 和 npm 的问题，而是 nvm-windows 的问题导致的，直接重启就能解决。\n然后使用管理员身份启动终端去更新npm版本即可。\n\n\n\n"},{"title":"python之pip的常见操作","url":"/2022/04/18/python%E4%B9%8Bpip%E7%9A%84%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C/","content":"一、pip切换镜像源\n临时切换（加上 -i 即可）： pip install 包名 -i https://pypi.tuna.tsinghua.edu.cn/simple\n\n永久切换（全局修改）：找到 pip.exe 程序所在的文件夹目录并进入，创建 pip.ini 文件并在 pip.ini 文件中输入以下内容：\n\n\n[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host = pypi.tuna.tsinghua.edu.cn\n\n二、pip常用命令\n查看配置信息： pip config list\n查看已安装的包： pip list\n拉取指定版本： pip install 包名 = 版本号\npip更新升级： python -m pip install --upgrade pip\n显示包所在的目录： pip show -f &lt;包名&gt;\n查询可升级的包： pip list -o\n\n","tags":["python"]},{"title":"【RocketMQ】RocketMQ存储结构设计 - shanml - 博客园","url":"//post/rocketmq-rocketmq-storage-structure-design-shanml-blog-park-zmavt4.html","content":"【RocketMQ】RocketMQ存储结构设计 - shanml - 博客园\n\nhttps://www.cnblogs.com/shanml/p/17703297.html\nCommitLog 生产者向Broker发送的消息，会以顺序写的方式，写入CommitLog文件，CommitLog文件的根目录由配置参数storePathRootDir决定，默认每一个CommitLog的文件大小为1G，如果文件写满会新建一个CommitLog文件，以该文件中第一条消息的偏移量为文\n2023-10-10 09:45:17\n\n\nCommitLog　　生产者向Broker发送的消息，会以顺序写的方式，写入CommitLog文件，CommitLog文件的根目录由配置参数storePathRootDir决定，默认每一个CommitLog的文件大小为1G，如果文件写满会新建一个CommitLog文件，以该文件中第一条消息的偏移量为文件名，小于20位用0补齐：​比如第一个文件中第一条消息的偏移量为0，那么第一个文件的名称为00000000000000000000，当这个文件存满之后，需要重新建立一个CommitLog文件，一个文件大小为1G，1GB &#x3D; 102410241024 &#x3D; 1073741824 Bytes，所以下一个文件就会被命名为00000000001073741824。\n数据格式　　CommitLog中存储的每条消息的数据格式如下：\n\n消息总长度，占4个字节；\n魔数，占4个字节；\n消息体CRC校验和，占4个字节；\n队列ID，占4个字节；\n标识，占4个字节；\n队列的偏移量，占8个字节；\n消息在文件的物理偏移量，占8个字节；\n系统标识，占4个字节；\n发送消息的时间戳，占8个字节；\n发送消息的主机地址，占8个字节；\n存储时间戳，占8个字节；\n存储消息的主机地址，占8个字节；\n消息的重试次数，占4个字节；\n事务相关偏移量，占8个字节；\n消息内容的长度，占4个字节；\n消息内容，由于消息内容不固定，所以长度不固定；\n主题名称的长度，占1个字节；\n主题名称内容，长度不固定；\n消息属性长度，占2个字节；\n消息属性内容，长度不固定；\n\n　　​​\n　　RocketMQ一般会保存一个物理偏移量offSet，从CommitLog中获取消息内容。\nConsumeQueue　　RocketMQ在消息存储的时候将消息顺序写入CommitLog文件，如果想根据Topic对消息进行查找，需要扫描所有CommitLog文件，这种方式性能低下，所以RocketMQ又设计了ConsumeQueue存储消息的逻辑偏移量，offset逻辑偏移量从0开始编号，进行递增，消息写入CommitLog以后，会构建对应的 ConsumeQueue文件。在RocketMQ的存储文件目录下，有一个consumequeue文件夹，里面按Topic分组，每个Topic一个文件夹，Topic文件夹内是该Topic的所有消息队列，以消息队列ID命名文件夹，每个消息队列都有自己对应的ConsumeQueue文件：​​\n　　ConsumeQueue中存储的每条数据大小是固定的，总共20个字节，数据格式如下：​​\n\n消息在CommitLog文件的偏移量，占用8个字节；\n消息大小，占用4个字节；\n消息Tag的hashcode值，用于tag过滤，占用8个字节；\n\n　　​​\n　　消费进度消费者在拉取消息进行消费的时候，就是通过这个ConsumeQueue实现的，消费者在向Broker发送消息拉取请求之前，需要知道应该从哪条消息开始消费，对于广播模式，消息的消费进度保存在消费者端本地，对于集群模式，消息的消费进度保存在Broker中，所以拉取某个消息队列的消息之前，会向Broker发送请求，获取该消息队列的消费进度，消费进度在RocketMQ的存储目录中有一个对应的文件，叫consumerOffset.json​，里面的offsetTable中保存了每个消息队列的消费进度，这个消费进度值对应的就是ConsumeQueue中的逻辑偏移量，它由定时任务定时进行持久化：\n&#123;\t&quot;offsetTable&quot;:&#123;\t\t&quot;TestTopic@TestTopicGroup&quot;:&#123; // 主题名称@消费者组名称            0:0, // 每个消息队列对应的消费进度，Key中的0表示队列0，value中的0表示消息在ConsumeQueue中的逻辑偏移量            1:1,            2:1,            3:0  \t\t&#125;\t&#125;&#125;\n\n　　拿到消息队列对应的消费进度时，就可以根据这个值从Broker拉取消息，Broker收到请求后，会根据这个值从ConsumeQueue中获取此条消息在CommitLog中的物理偏移量，根据物理偏移量再从CommitLog中获取消息内容返回给消费者。\n　　​​\n　　总结\n　　当消息写入CommitLog之后会构建对应的ConsumeQueue文件，每个消息队列MessageQueue都会有一个对应的ConsumeQueue文件，ConsumeQueue文件中的offset记录的是消息的逻辑索引，从0开始编号进行递增，比如存入了3条消息，那么对应的offset分别为0、1、2，消费者在消费的时候拿到的消费进度就是这个offset，然后根据offset从ConsumeQueue文件中获取数据，里面记录了消息在CommitLog文件中的物理偏移量，之后就可以从CommitLog中获取消息内容。\n　　消费者消费完毕之后，会保存这个消费进度，对于集群模式，消费进度会保存在Borker端，Broker会定时将消费进度进行持久化，如果消费者刚启动的时候，会向Broker发起请求获取之前记录的消费进度。\nIndexFile　　为了便于消息查找，RocketMQ还设计了IndexFile，支持根据Key对消息进行查找，在发送消息的时候可以设置一个唯一Keys值，用于标识这条消息，之后就可以根据这个Keys值对消息进行查找。\n\nKeys: 服务器会根据 keys 创建哈希索引，设置后，可以在 Console 系统根据 Topic、Keys 来查询消息，由于是哈希索引，请尽可能保证 key 唯一，例如订单号，商品 Id 等。\n\nMessage msg = new Message(topic, RandomUtils.getStringByUUID().getBytes());// 订单IdString orderId = &quot;20034568923546&quot;;msg.setKeys(orderId);\n\nIndexFile文件结构　　每个indexFile文件的大小是固定的，一个IndexFile文件大约可以保存2000W个消息的索引，IndexFile的文件结构如下：​​\n　　IndexHeaderindex header记录indexFile文件的整体信息，占40个字节，有以下信息：​​\n\nbeginTimestamp：当前indexFile文件中第一条消息的存储时间；\nendTimestamp：当前indexFile文件中最后一条消息存储时间；\nbeginPhyoffset：当前indexFile文件中第一条消息在Commitlog中的偏移量；\nendPhyoffset：当前indexFile文件中最后一条消息在commitlog中的偏移量；\nhashSlotCount：已经使用的hash槽的个数；\nindexCount：索引项中记录的所有消息索引总数；\n\n　　hash slotRocketMQ在每个IndexFile文件中划分了500W个hash槽，在向文件中添加消息索引的时候，会取出消息的Keys（实际会使用Topic + “#” + key进行拼装做为IndexFile文件的Key）计算hash值，然后对hash槽总数取余，来判断应该放到哪个hash槽。\n　　index item索引项中记录每个Key的索引信息，有以下部分组成：​​\n\nkeyHash：消息的key计算出来的的hashcode值，\nphyOffset：消息在CommitLog中的物理偏移量；\ntimeDiff：消息的存储时间减去IndexHeader中的beginTimestamp（当前indexFile文件中第一条消息的存储时间）；\npreIndexNo：当哈希冲突的时候，用于指向上一个索引，可以看做当哈希冲突的时候，使用一个链表将该哈希槽下的所有元素串起来，使用头插法增加新的元素；\n\n　　消息索引添加举个例子，比如现在有一条消息，它的Key值1，假设哈希槽的个数为10，这里对哈希计算简化，直接用1对哈希槽个数取余，得到值为0，那么这条消息将落入哈希槽0的位置，然后会在索引项区域建立该消息的索引信息：​​\n　　如果新增一条消息2，它的Key值为2，用2对哈希槽个数取余，依旧得到哈希槽0，此时产生哈希冲突，将哈希槽0处存储的值改为消息2的索引项，并将消息2索引项中的preIndexNo指向消息1的索引项，形成一个链表：​​\n　　参考孤翁-进阶篇 RocketMQ 原理之key查询迟钝先生-RocketMQ的Index File\n"},{"title":"测试","url":"//post/test-elan8.html","content":"测试‍\n"},{"title":"vue-cli项目迁移到vite遇到的问题和解决办法","url":"/2022/09/23/vue-cli%E9%A1%B9%E7%9B%AE%E8%BF%81%E7%A7%BB%E5%88%B0vite%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E5%92%8C%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","content":"为什么要迁移到vite？主要是构建速度上的差别，除此之外Vite也有一些其他的优势：\n\n构建速度：Vite相比Vue CLI最显著的优势应该就是构建速度，Vite基于esbuild预构建依赖，所以速度会快很多。\n打包方式更快\n\n迁移之后配置文件改变迁移后 vue.config.js 就不再使用了，使用vite.config.js文件来配置项目。其中配置相比vue.config.js更复杂一点，配置项更多。\n入口文件路径改变与Vue CLI不同，Vite会将index.html文件放置在项目的根目录中，而不是public目录中，因此需要移动它。并且在index.html我们也需要做一些改变：\n\n需要把“&lt;%&#x3D;BASE_URL%&gt;”占位符改为绝对路径。\n需要将&lt;%&#x3D; htmlWebpackPlugin.options.title %&gt;占位符改为硬编码值。\n应用程序不是自动注入的，所以需要手动引入。\n\n测试"},{"title":"vue全家桶以及各部分功能","url":"/2022/04/17/vue%E5%85%A8%E5%AE%B6%E6%A1%B6%E4%BB%A5%E5%8F%8A%E5%90%84%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD/","content":"1、vue全家桶vue全家桶包括：vue-cli（脚手架），vuex（状态管理），vueRouter（路由），Axios（网络请求）。\n2、各部分功能\nvue-cli ：\n 可以通过 vue create 快速搭建一个新项目，或者直接通过 vue serve 构建新想法的原型。\n\nvuex ：\n 是一个专为Vue.js 应用程序开发的状态管理模式+ 库。 它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。\n\nvueRouter ：\n 是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。vue的单页面应用是基于路由和组件的，路由用于设定访问路径，并将路径和组件映射起来。传统的页面应用，是用一些超链接来实现页面切换和跳转的。在vue-router单页面应用中，则是路径之间的切换，也就是组件的切换。\n\nAxios ：\n 一个基于promise 的HTTP 库，可以用在浏览器和node.js 中。 axios：前端通信框架，因为vue的边界很明确，就是为了处理DOM，所以并不具备通信功能，此时就需要额外使用一个通信框架与服务器交互；当然也可以使用jQuery提供的AJAX通信功能。\n\n\n","tags":["Vue"]},{"title":"yarn和npm的区别以及yarn的用法","url":"/2022/09/23/yarn%E5%92%8Cnpm%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8Ayarn%E7%9A%84%E7%94%A8%E6%B3%95/","content":"什么是yarn？yarn和npm都是JS包管理工具，且yarn是为了弥补npm中的缺陷而出现的。\n两者的区别\nyarn比npm速度快：\nyarn使用的是异步安装，而npm使用的是同步安装\nyarn安装过程信息很干净，npm会罗列很多其它包的信息\nyarn安装后是有个yarn.lock文件，这个文件是会锁定你安装的版本，别人安装时会直接读取yarn.lock文件，这样可以保证安装的依赖的版本是一样的，npm在5.x.x的版本也引入了这个机制，它的文件叫package-lock.json\n\nyarn优点\n速度快\n安装版本统一\n更简洁的输出\n\n"},{"title":"关于Webpack，npm、Node的简单介绍","url":"/2022/04/18/%E5%85%B3%E4%BA%8EWebpack%EF%BC%8Cnpm%E3%80%81Node%E7%9A%84%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/","content":"一、npm相关1、介绍npm 全称为 Node Package Manager，是一个基于 Node.js 的包管理器，是一个项目构建工具。它可以指定依赖库，设置项目属性等等，都在 package.json 配置文件里面。而 package.json 文件定义的是包，而 node_modules 文件夹则是存储模块的地方。便于js查找模块。npm主要是提供 node_module 的依赖支持, 而且是类似 maven 的 dependency tree 结构。\nnpm 由三个独立的部分组成：\n\n网站：是开发者查找包（package）、设置参数以及管理 npm 使用体验的主要途径。\n注册表（registry）：是一个巨大的数据库，保存了每个包（package）的信息。\n命令行工具 (CLI)：通过命令行或终端运行。开发者通过 CLI 与 npm 打交道。\n\n2、npm的全局安装和局部安装（ --save 和 --dev 区别）3、npm更换镜像源\n临时切换，通过 npm 命令指定下载源： npm --registry https://registry.npm.taobao.org install express\n永久修改，使用命令： npm config set registry https://registry.npm.taobao.org\n\n4、如何查看全局和局部的包5、npm 和 cnpm 的区别，会不会产生冲突6、npm如何更换包的版本二、webpack相关Webpack 是一个前端资源加载&#x2F;打包工具。它将根据模块的依赖关系进行静态分析，然后将这些模块按照指定的规则生成对应的静态资源。除此之外，webpack 因为可以提高兼容性，可以将一些浏览器尚不支持的新特性转换为可以支持格式，进而减少由新特性带来的浏览器的兼容性问题。\n\n三、node相关简单的说， Node.js 就是一个服务器端的、 非阻断式I&#x2F;O 的、事件驱动 的JavaScript运行环境。基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好，提供了一种可以让JS代码跑在后端的能力，这就是node。\n四、npm、webpack和node之间的联系webpack 是 npm 生态中的一个模块，webpack 的运行依赖于 node 的环境，没有 node 是不能打包的。但是 webpack 打包后的项目本身只是前端静态资源，和后台没有关系，也就是说不依赖于 node，只要有后台能力的都可以部署项目。\n","tags":["总结"]},{"title":"关于npm的一些基础设置和常用命令","url":"/2022/04/17/%E5%85%B3%E4%BA%8Enpm%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E7%A1%80%E8%AE%BE%E7%BD%AE%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","content":"1、换镜像源目前国内一般都使用淘宝镜像源，访问速度非常快。\n\nnpm查看当前使用源： npm config get registry\n临时切换，通过 npm 命令指定下载源： npm --registry https://registry.npm.taobao.org install express\n永久修改，使用命令： npm config set registry https://registry.npm.taobao.org\n切换官方源： npm config set registry https://registry.npmjs.org\n\n2、常用命令\n安装： npm install 模块名 （加-g全局安装；加–save安装运行时依赖）\n卸载： npm uninstall 模块名\n查找：\n查看模块安装目录： npm root （加 -g 为全局）\n查看全局安装的包： npm list -g --dept 0 （深度为0）\n查看配置信息： npm config list （查看详细配置： npm config list -l ）\n\n\n更新：\n包更新： npm undate 模块名\nnpm版本更新： npm update （更新的是当前目录下的 node_modules ）\nnpm更新升级： npm install n -g\n\n\n\n3、package.json文件的配置说明&#123;  &quot;name&quot;: &quot;blog&quot;,  //项目名称  &quot;version&quot;: &quot;0.0.0&quot;,   //版本  &quot;description&quot;: &quot;&quot;,   //项目描述  &quot;private&quot;: true,  &quot;main&quot;: &quot;index.js&quot;,  //入口文件  &quot;scripts&quot;: &#123;   //配置一些通用的命令脚本\t&quot;start&quot;: &quot;node ./bin/www&quot;  &#125;,  &quot;keywords&quot;: [],  //项目的关键字  &quot;author&quot;: &quot;&quot;,  //作者  &quot;dependencies&quot;: &#123;   //开发时的依赖\t&quot;body-parser&quot;: &quot;~1.16.0&quot;,\t&quot;cookie-parser&quot;: &quot;~1.4.3&quot;,\t&quot;debug&quot;: &quot;~2.6.0&quot;,\t&quot;ejs&quot;: &quot;~2.5.5&quot;,\t&quot;express&quot;: &quot;~4.14.1&quot;,\t&quot;morgan&quot;: &quot;~1.7.0&quot;,\t&quot;serve-favicon&quot;: &quot;~2.3.2&quot;  &#125;,  &quot;devDependencies&quot;: &#123;   //运行时的依赖\t&quot;express-session&quot;: &quot;^1.15.1&quot;  &#125;&#125;\n","tags":["node"]},{"title":"各种命名规范指南","url":"/2022/04/18/%E5%90%84%E7%A7%8D%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83%E6%8C%87%E5%8D%97/","content":"前言：为什么需要重视命名？\n这是因为好的命名即是注释，别人一看到你的命名就知道你的变量、方法或者类是做什么的！\n一、命名方法1、驼峰命名法\n小驼峰命名法 特点：除第一个单词之外，其他单词首字母大写。 应用：参数名、成员变量、局部变量、方法名。\n\n大驼峰命名法 特点：第一个单词的首字母大写，后边单词首字母也大写。 应用：类名、函数名、属性名、命名空间。\n\n\n2、蛇形命名法\n特点：个单词均小写，并且各个单词之间通过下划线“_”连接。\n应用：测试方法名、常量、枚举名。\n\n3、串式命名法\n特点：各个单词均小写并且单词之间通过连接符“-”连接。\n应用：项目名。\n\n二、常见命名规范1、Java 语言基本命名规范\n类名需要使用大驼峰命名法（UpperCamelCase）风格。方法名、参数名、成员变量、局部变量需要使用小驼峰命名法（lowerCamelCase）。\n测试方法名、常量、枚举名称需要使用蛇形命名法（snake_case），并且，测试方法名称要求全部小写，常量以及枚举名称需要全部大写。\n项目文件夹名称使用串式命名法（kebab-case）。\n包名统一使用小写，尽量使用单个名词作为包名，各个单词通过 “.” 分隔符连接，并且各个单词必须为单数。\n抽象类命名使用 Abstract 开头。\n异常类命名使用 Exception 结尾。\n测试类命名以它要测试的类的名称开始，以 Test 结尾。\nPOJO 类中布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列化错误。\n如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。\n\n2、命名易读性规范\n为了能让命名更加易懂和易读，尽量不要缩写&#x2F;简写单词，除非这些单词已经被公认可以被这样缩写&#x2F;简写。\n命名不像函数一样要尽量追求短，可读性强的名字优先于简短的名字，虽然可读性强的名字会比较长一点。 这个对应我们上面说的第 1 点。\n避免无意义的命名，你起的每一个名字都要能表明意思。\n避免命名过长（50 个字符以内最好），过长的命名难以阅读并且丑陋。\n不要使用拼音，更不要使用中文。不过像 alibaba 、wuhan、taobao 这种国际通用名词可以当做英文来看待。\n\n3、Vue命名规范三、相关工具\n变量命名神器（Codelf）:一个由国人开发的网站，网上有很多人称其为变量命名神器，Codelf 提供了在线网站版本，网址：https://unbug.github.io/codelf/。\n\n","categories":["编码规范"],"tags":["编码规范"]},{"title":"新手使用树莓派的总结","url":"/2022/04/19/%E6%96%B0%E6%89%8B%E4%BD%BF%E7%94%A8%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E6%80%BB%E7%BB%93/","content":"一、安装系统\n准备工具：一张大于8GB的SD卡、读卡器、树莓派一个、HDMI线（可无）、type-c充电线、支持 HDMI 输入的显示器（可无）、键盘鼠标（可无）。\n首先，需要先从官方下载页面下载Kali Linux镜像。在下载页面上找到ARM版本的镜像（img）进行下载到本地并进行解压，看实际情况选择32位还是64位。下载和解压时的路径尽量不要有中文，以免出现未知的错误。\n为了将Kali Linux镜像写入SD卡，利用一款名为“win 32 disk imager”的软件进行系统的写入。但是在这之前，最好先使用“SD Formatter”将SD卡进行格式化。进入win32 disk imager之后选择下载的镜像，点击写入即可。这个过程可能需要一些时间，因为它在写入镜像后会验证SD卡。\n\n\n\n\n系统写入完成后，分有无显示器两种情况。\n\n无显示器情况下：配置SSH：在boot目录下新建空文件ssh，注意没有任何后缀。配置无线网络：在boot目录下新建文件wpa_supplicant.conf, 内容如下：country=CNctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1network=&#123;ssid=&quot;名称，使用英语，保留引号&quot;psk=&quot;密码，保留引号&quot;priority=1    #优先级&#125;\n有显示器情况下：直接将树莓派连接上显示器，然后进行联网，最后使用ifconfig即可知道ip。然后就可以使用SSH连接树莓派进行操作了。\n\n\nkali系统使用时的默认用户名为：kali， 密码也为：kali。\n\n\n二、更换软件源\n只要编辑&#x2F;etc&#x2F;apt&#x2F;sources.list 文件：\nsudo nano /etc/apt/sources.list\n\n删除原文件所有内容，用以下内容取代：\ndeb http://mirror.sysu.edu.cn/raspbian/raspbian/jessiemain contrib non-freedeb-src http://mirror.sysu.edu.cn/raspbian/raspbian/jessiemain contrib non-free\n\n三、系统更新安装包问题\n成功进入系统后，首先联网升级一下软件包，使用下面两个命令：\nsudo apt updatesudo apt upgrade\n\n其中可能出现的升级问题：对apt软件包进行更新时报错：You don’t have enough free space in &#x2F;var&#x2F;cache&#x2F;apt&#x2F;archives&#x2F;.这是说明磁盘内存不够用了，可以使用软连接到其他内存大一点的目录下进行安装：\n\n首先清除原有的apt配置文件：sudo rm -rf /var/cache/apt/archives\n然后在内存大的目录下创建新的文件夹：sudo mkdir /dev/debs/partial\n然后进行软连接：sudo ln -s &quot;/dev/debs/partial&quot; /var/cache/apt/archives\n注意：不删除原有配置文件的话，会导致同样的报错。\n\n\n\n四、安装中文输入法\n中文字库安装完成之后，还需要安装一个中文输入法。输入如下命令：\napt-get -y install ttf-wqy-zenhei\n\n继续安装相关包：\napt-get -y install scim-pinyin\n\n安装完毕后输入：\nraspi-config\n\n然后选择Internationalisation options，然后选择change_locale，在Default locale for the system environment:中选择zh_CN.UTF-8,配置完成之后，输入命令：\nreboot\n\n命令之后重启即可显示中文。\n\n\n五、使用时的注意事项\n树莓派的电流大小一般稳定在：3.0A可以正常工作。 但是如果连接键盘和鼠标等外设的话，则需要计算一下电流电压再选择合适的电源适配器，以确保树莓派能够正常工作。\n使用sd卡安装系统过后，有的分区内存基本上所剩无几，使用：df -h查看各个分区磁盘使用情况，尽量将所有操作软连接到磁盘较大的分区下进行操作。\n禁止将树莓派的引脚短路，特别是VCC和GND，短路会造成芯片烧毁无法恢复。\nSD卡烧录系统完成时，系统会提示格式化，此时不需要格式化，点击取消即可。 若点了格式化后树莓派会提示缺失文件，需要重新烧录系统。\n\n","tags":["树莓派"]},{"title":"静态HTML页面传值的方法","url":"/2022/04/17/%E9%9D%99%E6%80%81HTML%E9%A1%B5%E9%9D%A2%E4%BC%A0%E5%80%BC%E7%9A%84%E6%96%B9%E6%B3%95/","content":"1、通过url传值示例如下：\n这是A页面：\n&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;A page&lt;/title&gt;    &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.2.1/jquery.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        $(document).ready(function () &#123;            // 拼接跳转url中要传输的数据            var dataList = [];            var dataStr;            dataList.push(&#x27;name&#x27;);//name、password为要传递的参数            dataList.push(&#x27;password&#x27;);            dataStr = window.JSON.stringify(dataList);            $(&#x27;#aPage&#x27;).on(&#x27;click&#x27;, function () &#123;                console.log(dataStr)                $(&#x27;#aPage&#x27;).attr(&quot;href&quot;, &quot;b.html?data=&quot; + dataStr);            &#125;)        &#125;);    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=&quot;b.html&quot; id=&quot;aPage&quot;&gt;在url里带数据跳转到b页面&lt;/a&gt;&lt;/body&gt;\n\n注意：JSON.stringify() 方法用于将 JavaScript 值转换为 JSON 字符串。\n这是B页面：\n&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;B page&lt;/title&gt;    &lt;script src=&quot;https://cdn.bootcss.com/jquery/3.2.1/jquery.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        $(document).ready(function () &#123;            //使用正则表达式获取url中的参数            function getUrlParam(name) &#123;                //构造一个含有目标参数的正则表达式对象                var reg = new RegExp(&quot;(^|&amp;)&quot; + name + &quot;=([^&amp;]*)(&amp;|$)&quot;);                //匹配目标参数，window.location.search获取页面url                var r = window.location.search.substr(1).match(reg);                //返回参数值                if (r != null) &#123;                    return unescape(r[2]);                &#125;                alert(&quot;出错了！&quot;);            &#125;            var urlData = getUrlParam(&#x27;data&#x27;);            // 将数据填充到input框里面            $(&#x27;#getUrlData&#x27;).val(urlData);        &#125;);    &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=&quot;text&quot; id=&quot;getUrlData&quot;&gt;&lt;/body&gt;\n\n注意：\n\nwindow.location.search.substr(1).match(reg);  \nlocation是包含了相关的url的信息，它是windown的一部分。  \nsearch是一个可以查询的属性，可以查询？之后的部分。\nsubstr(1)是为了去掉第一个？\nmatch()是你要匹配的部分 后面可以是正则表达式。\nreturn unescpe（r[2]） 返回的值 一个数组。  \n这里是开始匹配，找到了返回对应url值，没找到返回null。\n\n此方法不足之处： \n\nURL传递参数长度受限，最大为2K。 \nURL只能传递字符型参数，不能传递中文。 \n容易导致信息泄露，重要信息需要加密后才能传递。\n\n2、通过浏览器cookie传值3、通过form表单传值","tags":["web前端"]}]